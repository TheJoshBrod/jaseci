Semstrings (semantic strings) are a unique feature of Jac that allows you to define function behavior using natural language descriptions that are interpreted by Large Language Models (LLMs) instead of writing explicit code.

**LLM Model Setup**

Lines 3-8 set up the LLM model that will implement the function. Line 3 imports the `Model` class from the `byllm` module. Lines 5-8 create a global LLM instance using `glob llm = Model(...)`, specifying the model name as `"mockllm"` and providing mock outputs for testing purposes. In production, this would connect to an actual LLM service.

**Function Declaration with by llm()**

Line 11 demonstrates declaring a function to be implemented by an LLM using the `by llm()` syntax: `def generate_password() -> str by llm();`. This syntax tells Jac that instead of providing a traditional function body with code, the function's implementation will be generated by the LLM based on a semantic description.

The function signature includes:
- Function name: `generate_password`
- Return type: `-> str`
- Implementation directive: `by llm()` instead of a code block

**Semantic String Definition**

Lines 14-21 define the semantic string that describes what the function should do. The syntax is `sem function_name = """description""";`, where:
- `sem` is the keyword indicating a semantic string definition
- `generate_password` matches the function name from line 11
- The triple-quoted string contains the natural language specification

The semantic string on lines 14-21 provides detailed requirements for password generation:
- At least 8 characters long
- Contains uppercase letters
- Contains lowercase letters
- Contains digits
- Contains special characters

**How Semstrings Work**

When `generate_password()` is called on line 24, the following happens:
1. Jac recognizes the function is implemented by an LLM
2. The associated semantic string is sent to the configured LLM
3. The LLM interprets the requirements and generates a response
4. The response is returned as the function's output

**Execution**

Line 24 calls the LLM-implemented function like any normal function: `password = generate_password();`. The caller doesn't need to know or care that the function is implemented by an LLM rather than traditional code. Line 25 prints the generated password.

**Use Cases**

Semstrings are particularly useful for:
- Natural language processing tasks (text generation, summarization, translation)
- Tasks where specifying behavior is easier than implementing algorithms
- Rapid prototyping where you want to describe functionality before implementing it
- Integrating LLM capabilities seamlessly into Jac programs
- Creating AI-powered functions without complex prompt engineering

**Advantages**

The semstring approach provides several benefits:
- **Declarative**: Describe what you want, not how to do it
- **Maintainable**: Natural language descriptions can be easier to understand than complex code
- **Flexible**: Same semantic specification can work with different LLM models
- **Integrated**: LLM-powered functions work seamlessly with regular Jac code
- **Type-safe**: Function signatures include type annotations for inputs and outputs

**Implementation Note**

In this example, `mockllm` is used with predefined outputs (line 7) for testing purposes. In real applications, you would configure an actual LLM model (like GPT, Claude, or other models) to interpret the semantic strings and generate appropriate outputs.

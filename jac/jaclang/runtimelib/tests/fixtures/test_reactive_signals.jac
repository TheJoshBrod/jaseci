"""Test reactive state management primitives."""

cl import from jac:client_runtime {
    createSignal,
    createState,
    createEffect,
}

cl {
# Test 1: Basic signal get/set
def test_signal_basic() -> dict {
    [count, setCount] = createSignal(0);

    initial = count();
    setCount(5);
    updated = count();
    setCount(10);
    final = count();

    return {"initial": initial, "updated": updated, "final": final};
}

# Test 2: Signal with effect tracking
def test_signal_with_effect() -> dict {
    [count, setCount] = createSignal(0);
    effectRuns = 0;
    lastValue = 0;

    createEffect(lambda -> None {
        effectRuns = effectRuns + 1;
        lastValue = count();  # Track dependency
    });

    # Effect should have run once on creation
    runsAfterCreate = effectRuns;

    setCount(5);  # Should trigger effect
    runsAfterSet = effectRuns;
    valueAfterSet = lastValue;

    return {
        "runsAfterCreate": runsAfterCreate,
        "runsAfterSet": runsAfterSet,
        "valueAfterSet": valueAfterSet
    };
}

# Test 3: State object with shallow merge
def test_state_object() -> dict {
    [state, setState] = createState({"count": 0, "name": "Alice"});

    initial = state();

    # Update just count
    setState({"count": 5});
    afterCountUpdate = state();

    # Update just name
    setState({"name": "Bob"});
    afterNameUpdate = state();

    return {
        "initialCount": initial.count,
        "initialName": initial.name,
        "afterCountUpdate": afterCountUpdate.count,
        "afterNameUpdate": afterNameUpdate.name,
        "finalCount": afterNameUpdate.count
    };
}

# Test 4: Multiple signals
def test_multiple_signals() -> dict {
    [firstName, setFirstName] = createSignal("Alice");
    [lastName, setLastName] = createSignal("Smith");

    fullName1 = firstName() + " " + lastName();

    setFirstName("Bob");
    fullName2 = firstName() + " " + lastName();

    setLastName("Jones");
    fullName3 = firstName() + " " + lastName();

    return {
        "fullName1": fullName1,
        "fullName2": fullName2,
        "fullName3": fullName3
    };
}

# Test 5: Signal equality check (should not trigger on same value)
def test_signal_equality() -> dict {
    [count, setCount] = createSignal(5);
    effectRuns = 0;

    createEffect(lambda -> None {
        effectRuns = effectRuns + 1;
        count();  # Track dependency
    });

    runsAfterCreate = effectRuns;

    setCount(5);  # Same value - should not trigger
    runsAfterSameSet = effectRuns;

    setCount(10);  # Different value - should trigger
    runsAfterDifferentSet = effectRuns;

    return {
        "runsAfterCreate": runsAfterCreate,
        "runsAfterSameSet": runsAfterSameSet,
        "runsAfterDifferentSet": runsAfterDifferentSet
    };
}

# Test entry point
def test_all_reactive_signals() -> dict {
    return {
        "basic": test_signal_basic(),
        "withEffect": test_signal_with_effect(),
        "stateObject": test_state_object(),
        "multipleSignals": test_multiple_signals(),
        "equality": test_signal_equality()
    };
}
}

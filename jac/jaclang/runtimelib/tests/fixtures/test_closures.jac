"""Test closure support in Jac client code."""

cl {
# Test 1: Simple closure with outer variable
def make_counter() -> any {
    count = 0;

    def increment() -> int {
        count = count + 1;
        return count;
    }

    return increment;
}

# Test 2: Closure returning getter/setter pair
def create_signal_simple(initialValue: any) -> list {
    value = initialValue;

    def getter() -> any {
        return value;
    }

    def setter(newValue: any) -> None {
        value = newValue;
    }

    return [getter, setter];
}

# Test 3: Lambda closures
def make_adder(x: int) -> any {
    return lambda y: int : x + y;
}

# Test 4: Multiple closures sharing state
def create_shared_counter() -> dict {
    counter = 0;

    def increment() -> int {
        counter = counter + 1;
        return counter;
    }

    def decrement() -> int {
        counter = counter - 1;
        return counter;
    }

    def get_value() -> int {
        return counter;
    }

    return {"inc": increment, "dec": decrement, "get": get_value};
}

# Test entry point
def test_all_closures() -> dict {
    # Test 1
    counter = make_counter();
    val1 = counter();
    val2 = counter();

    # Test 2
    [get_count, set_count] = create_signal_simple(100);
    initial = get_count();
    set_count(200);
    updated = get_count();

    # Test 3
    add5 = make_adder(5);
    result = add5(10);

    # Test 4
    shared = create_shared_counter();
    shared["inc"]();
    shared["inc"]();
    count_val = shared["get"]();

    return {
        "counter1": val1,
        "counter2": val2,
        "initial": initial,
        "updated": updated,
        "adder_result": result,
        "shared_count": count_val
    };
}
}

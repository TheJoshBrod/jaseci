# The file was automatically generated by Lark v1.2.2
__version__ = "1.2.2"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar, Generic, Type, Tuple, List, Dict, Iterator, Collection, Callable, Optional, FrozenSet, Any,
    Union, Iterable, IO, TYPE_CHECKING, overload, Sequence,
    Pattern as REPattern, ClassVar, Set, Mapping
)


class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg='Got %r, expected one of %s'):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass

T = TypeVar('T')

class UnexpectedInput(LarkError):
    #--
    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: 'InteractiveParser'

    def get_context(self, text: str, span: int=40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit('\n', 1)[-1]
            after = text[pos:end].split('\n', 1)[0]
            return before + after + '\n' + ' ' * len(before.expandtabs()) + '^\n'
        else:
            before = text[start:pos].rsplit(b'\n', 1)[-1]
            after = text[pos:end].split(b'\n', 1)[0]
            return (before + after + b'\n' + b' ' * len(before.expandtabs()) + b'^\n').decode("ascii", "backslashreplace")

    def match_examples(self, parse_fn: 'Callable[[str], Tree]',
                             examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
                             token_type_match_fallback: bool=False,
                             use_accepts: bool=True
                         ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug("Different accepts with same state[%d]: %s != %s at example [%s][%s]" %
                                         (self.state, self.accepts, ut.accepts, i, j))
                            continue
                        if (
                            isinstance(self, (UnexpectedToken, UnexpectedEOF))
                            and isinstance(ut, (UnexpectedToken, UnexpectedEOF))
                        ):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[-1]:
                                    logger.debug("Token Type Fallback at example [%s][%s]" % (i, j))
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug("Same State match at example [%s][%s]" % (i, j))
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [d[t_name].user_repr() if t_name in d else t_name for t_name in expected]
        return "Expected one of: \n\t* %s\n" % '\n\t* '.join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--
    expected: 'List[Token]'

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token
        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name


    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(self, seq, lex_pos, line, column, allowed=None, considered_tokens=None, state=None, token_history=None,
                 terminals_by_name=None, considered_rules=None):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos:lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)


    def __str__(self):
        message = "No terminal matches '%s' in the current parser context, at line %d col %d" % (self.char, self.line, self.column)
        message += '\n\n' + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += '\nPrevious tokens: %s\n' % ', '.join(repr(t) for t in self.token_history)
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(self, token, expected, considered_rules=None, state=None, interactive_parser=None, terminals_by_name=None, token_history=None):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, 'line', '?')
        self.column = getattr(token, 'column', '?')
        self.pos_in_stream = getattr(token, 'start_pos', None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history


    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = self.interactive_parser and self.interactive_parser.accepts()
        return self._accepts

    def __str__(self):
        message = ("Unexpected token %r at line %s, column %s.\n%s"
                   % (self.token, self.line, self.column, self._format_expected(self.accepts or self.expected)))
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message



class VisitError(LarkError):
    #--

    obj: 'Union[Tree, Token]'
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass


import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if '__type__' in data:  ##

            class_ = namespace[data['__type__']]
            return class_.deserialize(data, memo)
        elif '@' in data:
            return memo[data['@']]
        return {key:_deserialize(value, namespace, memo) for key, value in data.items()}
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")

class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo = None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {'@': memo.memoized.get(self)}

        fields = getattr(self, '__serialize_fields__')
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res['__type__'] = type(self).__name__
        if hasattr(self, '_serialize'):
            self._serialize(res, memo)
        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, '__serialize_namespace__', [])
        namespace = {c.__name__:c for c in namespace}

        fields = getattr(cls, '__serialize_fields__')

        if '@' in data:
            return memo[data['@']]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, '_deserialize'):
            inst._deserialize()

        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = 'memoized',

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex
    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r'\\p{[A-Za-z_]+}')

def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, 'A', expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError('`regex` module must be installed in order to use Unicode categories.', expr)
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]
    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            ##

            ##

            MAXWIDTH = getattr(sre_parse, "MAXWIDTH", sre_constants.MAXREPEAT)
            if c.match('') is None:
                ##

                return 1, int(MAXWIDTH)
            else:
                return 0, int(MAXWIDTH)



class Meta:

    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: 'List[TerminalDef]'
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, 'Tree[_Leaf_T]']


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: 'List[Branch[_Leaf_T]]'

    def __init__(self, data: str, children: 'List[Branch[_Leaf_T]]', meta: Optional[Meta]=None) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return 'Tree(%r, %r)' % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f'{indent_str*level}{self._pretty_label()}'
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f'\t{self.children[0]}\n'
        else:
            yield '\n'
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level+1, indent_str)
                else:
                    yield f'{indent_str*(level+1)}{n}\n'

    def pretty(self, indent_str: str='  ') -> str:
        #--
        return ''.join(self._pretty(0, indent_str))

    def __rich__(self, parent:Optional['rich.tree.Tree']=None) -> 'rich.tree.Tree':
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f'[bold]{self.data}[/bold]')
        else:
            import rich.tree
            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f'[green]{c}[/green]')

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> 'Iterator[Tree[_Leaf_T]]':
        #--
        queue = [self]
        subtrees = dict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            queue += [c for c in reversed(subtree.children)
                      if isinstance(c, Tree) and id(c) not in subtrees]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(self, pred: 'Callable[[Tree[_Leaf_T]], bool]') -> 'Iterator[Tree[_Leaf_T]]':
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> 'Iterator[Tree[_Leaf_T]]':
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar('_Return_T')
_Return_V = TypeVar('_Return_V')
_Leaf_T = TypeVar('_Leaf_T')
_Leaf_U = TypeVar('_Leaf_U')
_R = TypeVar('_R')
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]

class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"

Discard = _DiscardType()

##


class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):

            ##

            if name.startswith('_') or (name in libmembers and name not in cls.__dict__):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--
    __visit_tokens__ = True   ##


    def __init__(self,  visit_tokens: bool=True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, 'visit_wrapper', None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        res = list(self._transform_children([tree]))
        if not res:
            return None     ##

        assert len(res) == 1
        return res[0]

    def __mul__(
            self: 'Transformer[_Leaf_T, Tree[_Leaf_U]]',
            other: 'Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]'
    ) -> 'TransformerChain[_Leaf_T, _Return_V]':
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError("Cannot merge: method '%s' appears more than once" % prefixed_method)

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):   ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):

    transformers: 'Tuple[Union[Transformer, TransformerChain], ...]'

    def __init__(self, *transformers: 'Union[Transformer, TransformerChain]') -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
            self: 'TransformerChain[_Leaf_T, Tree[_Leaf_U]]',
            other: 'Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]'
    ) -> 'TransformerChain[_Leaf_T, _Return_V]':
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--
    def _transform_tree(self, tree):           ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        result, = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--
    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##


class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self,tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, 'visit_wrapper', None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [self._visit_tree(child) if isinstance(child, Tree) else child
                for child in tree.children]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]

def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--
    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)
    return inner

##


def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--
    base_func: Callable

    def __init__(self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        self.base_func = func
        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)
def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)
def _vargs_meta(f, _data, children, meta):
    return f(meta, children)
def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(inline: bool = False, meta: bool = False, tree: bool = False, wrapper: Optional[Callable] = None) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError("Visitor functions cannot combine 'tree' with 'meta' or 'inline'.")

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError("Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'.")
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)
    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ('name',)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return '%s(%r)' % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = 'name', 'filter_out'

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return '%s(%r, %r)' % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = 'name',

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = 'keep_all_tokens', 'expand1', 'priority', 'template_source', 'empty_indices'

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(self, keep_all_tokens: bool=False, expand1: bool=False, priority: Optional[int]=None, template_source: Optional[str]=None, empty_indices: Tuple[bool, ...]=()) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return 'RuleOptions(%r, %r, %r, %r)' % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source
        )


class Rule(Serialize):
    #--
    __slots__ = ('origin', 'expansion', 'alias', 'options', 'order', '_hash')

    __serialize_fields__ = 'origin', 'expansion', 'order', 'alias', 'options'
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(self, origin: NonTerminal, expansion: Sequence[Symbol],
                 order: int=0, alias: Optional[str]=None, options: Optional[RuleOptions]=None):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return '<%s : %s>' % (self.origin.name, ' '.join(x.name for x in self.expansion))

    def __repr__(self):
        return 'Rule(%r, %r, %r, %r)' % (self.origin, self.expansion, self.alias, self.options)

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False

class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(self, value: str, flags: Collection[str] = (), raw: Optional[str] = None) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return type(self) == type(other) and self.value == other.value and self.flags == other.flags

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = ('(?%s:%s)' % (f, value))
        return value


class PatternStr(Pattern):
    __serialize_fields__ = 'value', 'flags', 'raw'

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = 'value', 'flags', 'raw', '_width'

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None
    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = 'name', 'pattern', 'priority'
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return '%s(%r, %r)' % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith('__'):  ##

            return self.pattern.raw or self.name
        else:
            return self.name

_T = TypeVar('_T', bound="Token")

class Token(str):
    #--
    __slots__ = ('type', 'start_pos', 'value', 'line', 'column', 'end_line', 'end_column', 'end_pos')

    __match_args__ = ('type', 'value')

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]


    @overload
    def __new__(
            cls,
            type: str,
            value: Any,
            start_pos: Optional[int] = None,
            line: Optional[int] = None,
            column: Optional[int] = None,
            end_line: Optional[int] = None,
            end_column: Optional[int] = None,
            end_pos: Optional[int] = None
    ) -> 'Token':
        ...

    @overload
    def __new__(
            cls,
            type_: str,
            value: Any,
            start_pos: Optional[int] = None,
            line: Optional[int] = None,
            column: Optional[int] = None,
            end_line: Optional[int] = None,
            end_column: Optional[int] = None,
            end_pos: Optional[int] = None
    ) -> 'Token':        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn("`type_` is deprecated use `type` instead", DeprecationWarning)

            if "type" in kwargs:
                raise TypeError("Error: using both 'type' and the deprecated 'type_' as arguments.")
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)


    @classmethod
    def _future_new(cls, type, value, start_pos=None, line=None, column=None, end_line=None, end_column=None, end_pos=None):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(self, type: Optional[str] = None, value: Optional[Any] = None) -> 'Token':
        ...

    @overload
    def update(self, type_: Optional[str] = None, value: Optional[Any] = None) -> 'Token':
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn("`type_` is deprecated use `type` instead", DeprecationWarning)

            if "type" in kwargs:
                raise TypeError("Error: using both 'type' and the deprecated 'type_' as arguments.")
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(self, type: Optional[str] = None, value: Optional[Any] = None) -> 'Token':
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: 'Token') -> _T:
        return cls(type_, value, borrow_t.start_pos, borrow_t.line, borrow_t.column, borrow_t.end_line, borrow_t.end_column, borrow_t.end_pos)

    def __reduce__(self):
        return (self.__class__, (self.type, self.value, self.start_pos, self.line, self.column))

    def __repr__(self):
        return 'Token(%r, %r)' % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = 'char_pos', 'line', 'column', 'line_start_pos', 'newline_char'

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return self.char_pos == other.char_pos and self.newline_char == other.newline_char

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = self.char_pos + token.rindex(self.newline_char) + 1

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)

def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(Scanner(unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes))

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = '$' if self.match_whole else ''
        mres = []
        while terminals:
            pattern = u'|'.join(u'(?P<%s>%s)' % (t.name, t.pattern.to_regexp() + postfix) for t in terminals[:max_size])
            if self.use_bytes:
                pattern = pattern.encode('latin-1')
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return '\n' in r or '\\n' in r or '\\s' in r or '[^' in r or ('(?s' in r and '.' in r)


class LexerState:
    #--

    __slots__ = 'text', 'line_ctr', 'last_token'

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(self, text: str, line_ctr: Optional[LineCounter]=None, last_token: Optional[Token]=None):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(b'\n' if isinstance(text, bytes) else '\n')
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return self.text is other.text and self.line_ctr == other.line_ctr and self.last_token == other.last_token

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: 'Lexer', lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: 'Lexer', text: str) -> 'LexerThread':
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]

class Lexer(ABC):
    #--
    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(terminal_to_regexp: Dict[TerminalDef, str], comparator, strict_mode, max_collisions_to_show=8):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(a, b, max_time).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning("%s The lexer will choose between them arbitrarily.\n%s", message, example)
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: 'LexerConf', comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: 'LexerConf', comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError("Lexer does not allow zero-width terminals. (%s: %s)" % (t.name, t.pattern))
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError("Ignore terminals are not defined: %s" % (set(conf.ignore) - {t.name for t in terminals}))

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError("interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`.")

        ##

        self.newline_types = frozenset(t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp()))
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(key=lambda x: (-x.priority, -x.pattern.max_width, -len(x.pattern.value), x.name))
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(self.terminals, self.g_regex_flags, self.re, self.use_bytes)
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(self.callback[type_], f, lambda t: t.type == type_)
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(lex_state.text, line_ctr.char_pos, line_ctr.line, line_ctr.column,
                                           allowed=allowed, token_history=lex_state.last_token and [lex_state.last_token],
                                           state=parser_state, terminals_by_name=self.terminals_by_name)

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column)
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError("Callbacks must return a token (returned %r)" % t)
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(self, conf: 'LexerConf', states: Dict[int, Collection[str]], always_accept: Collection[str]=()) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes({t: t.pattern.to_regexp() for t in terminals})
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [terminals_by_name[n] for n in accepts if n in terminals_by_name]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(self, lexer_state: LexerState, parser_state: 'ParserState') -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = lexer_state.last_token  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(token, e.allowed, state=parser_state, token_history=[last_token], terminals_by_name=self.root_lexer.terminals_by_name)
            except UnexpectedCharacters:
                raise e  ##




_ParserArgType: 'TypeAlias' = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: 'TypeAlias' = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]

class LexerConf(Serialize):
    __serialize_fields__ = 'terminals', 'ignore', 'g_regex_flags', 'use_bytes', 'lexer_type'
    __serialize_namespace__ = TerminalDef,

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: 'Optional[PostLex]'
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(self, terminals: Collection[TerminalDef], re_module: ModuleType, ignore: Collection[str]=(), postlex: 'Optional[PostLex]'=None,
                 callbacks: Optional[Dict[str, _LexerCallback]]=None, g_regex_flags: int=0, skip_validation: bool=False, use_bytes: bool=False, strict: bool=False):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )

class ParserConf(Serialize):
    __serialize_fields__ = 'rules', 'start', 'parser_type'

    rules: List['Rule']
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(self, rules: List['Rule'], callbacks: ParserCallbacks, start: List[str]):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start


from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)



class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, 'line'):
                    ##

                    res_meta.line = getattr(first_meta, 'container_line', first_meta.line)
                    res_meta.column = getattr(first_meta, 'container_column', first_meta.column)
                    res_meta.start_pos = getattr(first_meta, 'container_start_pos', first_meta.start_pos)
                    res_meta.empty = False

                res_meta.container_line = getattr(first_meta, 'container_line', first_meta.line)
                res_meta.container_column = getattr(first_meta, 'container_column', first_meta.column)
                res_meta.container_start_pos = getattr(first_meta, 'container_start_pos', first_meta.start_pos)

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, 'end_line'):
                    res_meta.end_line = getattr(last_meta, 'container_end_line', last_meta.end_line)
                    res_meta.end_column = getattr(last_meta, 'container_end_column', last_meta.end_column)
                    res_meta.end_pos = getattr(last_meta, 'container_end_pos', last_meta.end_pos)
                    res_meta.empty = False

                res_meta.container_end_line = getattr(last_meta, 'container_end_line', last_meta.end_line)
                res_meta.container_end_column = getattr(last_meta, 'container_end_column', last_meta.end_column)
                res_meta.container_end_pos = getattr(last_meta, 'container_end_pos', last_meta.end_pos)

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, '__lark_meta__'):
                return c.__lark_meta__()

def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError('Invalid option for propagate_positions: %r' % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:   ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--
    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:   ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith('_')


def maybe_create_child_filter(expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = ''.join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split('0')]
        assert len(empty_indices) == len(expansion)+1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion)+1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if _empty_indices or len(to_include) < len(expansion) or any(to_expand for i, to_expand,_ in to_include):
        if _empty_indices or ambiguous:
            return partial(ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add)
        else:
            ##

            return partial(ChildFilterLALR_NoPlaceholders, [(i, x) for i,x,_ in to_include])


class AmbiguousExpander:
    #--
    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, 'data') and t.data == '_ambig'

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data('_ambig')

        if not ambiguous:
            return self.node_builder(children)

        expand = [child.children if i in ambiguous else (child,) for i, child in enumerate(children)]
        return self.tree_class('_ambig', [self.node_builder(list(f)) for f in product(*expand)])


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [i for i, sym in enumerate(expansion)
                 if keep_all_tokens or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, 'data') and child.data == '_iambig'

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class('_inter', grandchild.children + children[1:])
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class('_ambig', processed_nodes)

        return self.node_builder(children)



def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)
    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)
    return f


class ParseTreeBuilder:
    def __init__(self, rules, tree_class, propagate_positions=False, ambiguous=False, maybe_placeholders=False):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(filter(None, [
                (expand_single_child and not rule.alias) and ExpandSingleChild,
                maybe_create_child_filter(rule.expansion, keep_all_tokens, self.ambiguous, options.empty_indices if self.maybe_placeholders else None),
                propagate_positions,
                self.ambiguous and maybe_create_ambiguous_expander(self.tree_class, rule.expansion, keep_all_tokens),
                self.ambiguous and partial(AmbiguousIntermediateExpander, self.tree_class)
            ]))

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, '__default__', None)
        if default_handler:
            def default_callback(data, children):
                return default_handler(data, children, None)
        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:

            user_callback_name = rule.alias or rule.options.template_source or rule.origin.name
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, 'visit_wrapper', None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks



class Action:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def __repr__(self):
        return str(self)

Shift = Action('Shift')
Reduce = Action('Reduce')

StateT = TypeVar("StateT")

class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {tokens.get(token): ((1, arg.serialize(memo)) if action is Reduce else (0, arg))
                    for token, (action, arg) in actions.items()}
            for state, actions in self.states.items()
        }

        return {
            'tokens': tokens.reversed(),
            'states': states,
            'start_states': self.start_states,
            'end_states': self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data['tokens']
        states = {
            state: {tokens[token]: ((Reduce, Rule.deserialize(arg, memo)) if action==1 else (Shift, arg))
                    for token, (action, arg) in actions.items()}
            for state, actions in data['states'].items()
        }
        return cls(states, data['start_states'], data['end_states'])

class ParseTable(ParseTableBase['State']):
    #--
    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict['State', int] = {s:i for i,s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {k:(v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                  for k,v in la.items()}
            int_states[ state_to_idx[s] ] = la


        start_states = {start:state_to_idx[s] for start, s in parse_table.start_states.items()}
        end_states = {start:state_to_idx[s] for start, s in parse_table.end_states.items()}
        return cls(int_states, start_states, end_states)



class ParseConf(Generic[StateT]):
    __slots__ = 'parse_table', 'callbacks', 'start', 'start_state', 'end_state', 'states'

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(self, parse_table: ParseTableBase[StateT], callbacks: ParserCallbacks, start: str):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start

class ParserState(Generic[StateT]):
    __slots__ = 'parse_conf', 'lexer', 'state_stack', 'value_stack'

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(self, parse_conf: ParseConf[StateT], lexer: LexerThread, state_stack=None, value_stack=None):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return len(self.state_stack) == len(other.state_stack) and self.position == other.position

    def __copy__(self):
        return self.copy()

    def copy(self, deepcopy_values=True) -> 'ParserState[StateT]':
        return type(self)(
            self.parse_conf,
            self.lexer, ##

            copy(self.state_stack),
            deepcopy(self.value_stack) if deepcopy_values else copy(self.value_stack),
        )

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(token, expected, state=self, interactive_parser=None)

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(token if token.type not in callbacks else callbacks[token.type](token))
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]


class LALR_Parser(Serialize):
    def __init__(self, parser_conf: ParserConf, debug: bool=False, strict: bool=False):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p:p+1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == '$END'
                        and e.interactive_parser == e2.interactive_parser):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(self, parse_table: ParseTableBase, callbacks: ParserCallbacks, debug: bool=False):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(self, lexer: LexerThread, start: str, value_stack=None, state_stack=None, start_interactive=False):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)


    def parse_from_state(self, state: ParserState, last_token: Optional[Token]=None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = Token.new_borrow_pos('$END', '', token) if token else Token('$END', '', 0, 1, 1)
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print('%d)' % i , s)
                print("")

            raise


class InteractiveParser:
    #--
    def __init__(self, parser, parser_state: ParserState, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn("lexer_state will be removed in subsequent releases. Use lexer_thread instead.", DeprecationWarning)
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == '$END')

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())


    def feed_eof(self, last_token=None):
        #--
        eof = Token.new_borrow_pos('$END', '', last_token) if last_token is not None else self.lexer_thread._Token('$END', '', 0, 1, 1)
        return self.feed_token(eof)


    def __copy__(self):
        #--
        return self.copy()

    def copy(self, deepcopy_values=True):
        return type(self)(
            self.parser,
            self.parser_state.copy(deepcopy_values=deepcopy_values),
            copy(self.lexer_thread),
        )

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return self.parser_state == other.parser_state and self.lexer_thread == other.lexer_thread

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append('\t- %s -> %r' % (k, v))
        out.append('stack size: %s' % len(self.parser_state.state_stack))
        return '\n'.join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[self.parser_state.position]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper(): ##

                new_cursor = self.copy(deepcopy_values=False)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ''))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(self.parser_state, last_token=self.lexer_thread.state.last_token)



class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)



def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, '__future_interface__', False)
    if future_interface:
        return lexer_class
    else:
        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)
            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)
        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data['parser_conf'], memo)
    cls = (options and options._plugins.get('LALR_Parser')) or LALR_Parser
    parser = cls.deserialize(data['parser'], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: 'Dict[str, Callable[[LexerConf, Any, Any], Any]]' = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = 'lexer_conf', 'parser_conf', 'parser'

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert create_parser is not None, "{} is not supported in standalone mode".format(
                    parser_conf.parser_type
                )
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ('dynamic', 'dynamic_complete'):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                'basic': create_basic_lexer,
                'contextual': create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(lexer_conf, self.parser, lexer_conf.postlex, options)
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError("Lark initialized with more than 1 possible start rule. Must specify which start rule to parse", start_decls)
            start ,= start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError("Unknown start rule %s. Must be one of %r" % (start, self.parser_conf.start))
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get('LexerThread')) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {'on_error': on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str]=None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != 'lalr':
            raise ConfigurationError("parse_interactive() currently only works with parser='lalr' ")
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ('lalr', 'earley', 'cyk'))
    if not isinstance(lexer, type):     ##

        expected = {
            'lalr': ('basic', 'contextual'),
            'earley': ('basic', 'dynamic', 'dynamic_complete'),
            'cyk': ('basic', ),
         }[parser]
        assert_config(lexer, expected, 'Parser %r does not support lexer %%r, expected one of %%s' % parser)


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result

class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)



def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get('BasicLexer')) or BasicLexer
    return cls(lexer_conf)

def create_contextual_lexer(lexer_conf: LexerConf, parser, postlex, options) -> ContextualLexer:
    cls = (options and options._plugins.get('ContextualLexer')) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {idx:list(t.keys()) for idx, t in parse_table.states.items()}
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)

def create_lalr_parser(lexer_conf: LexerConf, parser_conf: ParserConf, options=None) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get('LALR_Parser')) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)

_parser_creators['lalr'] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()

class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: 'Optional[Transformer]'
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: 'List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]'
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC


    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        'debug': False,
        'strict': False,
        'keep_all_tokens': False,
        'tree_class': None,
        'cache': False,
        'postlex': None,
        'parser': 'earley',
        'lexer': 'auto',
        'transformer': None,
        'start': 'start',
        'priority': 'auto',
        'ambiguity': 'auto',
        'regex': False,
        'propagate_positions': False,
        'lexer_callbacks': {},
        'maybe_placeholders': True,
        'edit_terminals': None,
        'g_regex_flags': 0,
        'use_bytes': False,
        'ordered_sets': True,
        'import_paths': [],
        'source_path': None,
        '_plugins': {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in ('cache', 'use_bytes', 'propagate_positions'):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options['start'], str):
            options['start'] = [options['start']]

        self.__dict__['options'] = options


        assert_config(self.parser, ('earley', 'lalr', 'cyk', None))

        if self.parser == 'earley' and self.transformer:
            raise ConfigurationError('Cannot specify an embedded transformer when using the Earley algorithm. '
                             'Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)')

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__['options'][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(name, self.options.keys(), "%r isn't a valid option. Expected one of: %s")
        self.options[name] = value

    def serialize(self, memo = None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {'postlex', 'transformer', 'lexer_callbacks', 'use_bytes', 'debug', 'g_regex_flags', 'regex', 'propagate_positions', 'tree_class', '_plugins'}

_VALID_PRIORITY_OPTIONS = ('auto', 'normal', 'invert', None)
_VALID_AMBIGUITY_OPTIONS = ('auto', 'resolve', 'explicit', 'forest')


_T = TypeVar('_T', bound="Lark")

class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: 'Grammar'
    options: LarkOptions
    lexer: Lexer
    parser: 'ParsingFrontend'
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: 'Union[Grammar, str, IO[str]]', **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError('`regex` module must be installed if calling `Lark(regex=True)`.')
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = '<string>'
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not grammar.isascii():
                    raise ConfigurationError("Grammar must be ascii only, when use_bytes=True")

            if self.options.cache:
                if self.options.parser != 'lalr':
                    raise ConfigurationError("cache only works with parser='lalr' for now")

                unhashable = ('transformer', 'postlex', 'lexer_callbacks', 'edit_terminals', '_plugins')
                options_str = ''.join(k+str(v) for k, v in options.items() if k not in unhashable)
                from . import __version__
                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = tempfile.gettempdir() + "/.lark_cache_%s_%s_%s_%s.tmp" % (username, cache_sha256, *sys.version_info[:2])

                old_options = self.options
                try:
                    with FS.open(cache_fn, 'rb') as f:
                        logger.debug('Loading grammar from cache: %s', cache_fn)
                        ##

                        for name in (set(options) - _LOAD_ALLOWED_OPTIONS):
                            del options[name]
                        file_sha256 = f.readline().rstrip(b'\n')
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode('utf8') and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except Exception: ##

                    logger.exception("Failed to load Lark from cache: %r. We will try to carry on.", cache_fn)

                    ##

                    ##

                    self.options = old_options


            ##

            self.grammar, used_files = load_grammar(grammar, self.source_path, self.options.import_paths, self.options.keep_all_tokens)
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar


        if self.options.lexer == 'auto':
            if self.options.parser == 'lalr':
                self.options.lexer = 'contextual'
            elif self.options.parser == 'earley':
                if self.options.postlex is not None:
                    logger.info("postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                                "Consider using lalr with contextual instead of earley")
                    self.options.lexer = 'basic'
                else:
                    self.options.lexer = 'dynamic'
            elif self.options.parser == 'cyk':
                self.options.lexer = 'basic'
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(lexer, Lexer)     ##

        else:
            assert_config(lexer, ('basic', 'contextual', 'dynamic', 'dynamic_complete'))
            if self.options.postlex is not None and 'dynamic' in lexer:
                raise ConfigurationError("Can't use postlex with a dynamic lexer. Use basic or contextual instead")

        if self.options.ambiguity == 'auto':
            if self.options.parser == 'earley':
                self.options.ambiguity = 'resolve'
        else:
            assert_config(self.options.parser, ('earley', 'cyk'), "%r doesn't support disambiguation. Use one of these parsers instead: %s")

        if self.options.priority == 'auto':
            self.options.priority = 'normal'

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError("invalid priority option: %r. Must be one of %r" % (self.options.priority, _VALID_PRIORITY_OPTIONS))
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError("invalid ambiguity option: %r. Must be one of %r" % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS))

        if self.options.parser is None:
            terminals_to_keep = '*'
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(self.options.start, terminals_to_keep)

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == 'invert':
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
                self.terminals, re_module, self.ignore_tokens, self.options.postlex,
                self.options.lexer_callbacks, self.options.g_regex_flags, use_bytes=self.options.use_bytes, strict=self.options.strict
            )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug('Saving grammar to cache: %s', cache_fn)
            try:
                with FS.open(cache_fn, 'wb') as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode('utf8') + b'\n')
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = 'parser', 'rules', 'options'

    def _build_lexer(self, dont_ignore: bool=False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy
            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != 'forest':
            self._parse_tree_builder = ParseTreeBuilder(
                    self.rules,
                    self.options.tree_class or Tree,
                    self.options.propagate_positions,
                    self.options.parser != 'lalr' and self.options.ambiguity == 'explicit',
                    self.options.maybe_placeholders
                )
            self._callbacks = self._parse_tree_builder.create_callback(self.options.transformer)
        self._callbacks.update(_get_lexer_callbacks(self.options.transformer, self.terminals))

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != 'lalr':
            raise NotImplementedError("Lark.save() is only implemented for the LALR(1) parser.")
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {n: v for n, v in data["options"].items() if n not in exclude_options}
        pickle.dump({'data': data, 'memo': m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(self, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]], options: LarkOptions) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data['lexer_conf'], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d['memo']
        data = d['data']

        assert memo_json
        memo = SerializeMemoizer.deserialize(memo_json, {'Rule': Rule, 'TerminalDef': TerminalDef}, {})
        options = dict(data['options'])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError("Some options are not allowed when loading a Parser: {}"
                             .format(set(kwargs) - _LOAD_ALLOWED_OPTIONS))
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data['rules']]
        self.source_path = '<deserialized>'
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(data['parser'], memo, self.options)
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data['parser'],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({'data': data, 'memo': memo}, **kwargs)

    @classmethod
    def open(cls: Type[_T], grammar_filename: str, rel_to: Optional[str]=None, **options) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding='utf8') as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(cls: Type[_T], package: str, grammar_path: str, search_paths: 'Sequence[str]'=[""], **options) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault('source_path', full_path)
        options.setdefault('import_paths', [])
        options['import_paths'].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return 'Lark(open(%r), parser=%r, lexer=%r, ...)' % (self.source_path, self.options.parser, self.options.lexer)


    def lex(self, text: str, dont_ignore: bool=False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, 'lexer') or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(self, text: Optional[str]=None, start: Optional[str]=None) -> 'InteractiveParser':
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(self, text: str, start: Optional[str]=None, on_error: 'Optional[Callable[[UnexpectedInput], bool]]'=None) -> 'ParseTree':
        #--
        return self.parser.parse(text, start=start, on_error=on_error)




class DedentError(LarkError):
    pass

class Indenter(PostLex, ABC):
    #--
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit('\n', 1)[1] ##

        indent = indent_str.count(' ') + indent_str.count('\t') * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError('Unexpected dedent to column %s. Expected dedent to %s' % (indent, self.indent_level[-1]))

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, '')

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        #--
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        #--
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        #--
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        #--
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        #--
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        #--
        raise NotImplementedError()


class PythonIndenter(Indenter):
    #--

    NL_type = '_NEWLINE'
    OPEN_PAREN_types = ['LPAR', 'LSQB', 'LBRACE']
    CLOSE_PAREN_types = ['RPAR', 'RSQB', 'RBRACE']
    INDENT_type = '_INDENT'
    DEDENT_type = '_DEDENT'
    tab_len = 8


import pickle, zlib, base64
DATA = (
b'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ETofuhQ6E7oFGoGS0FnQCVAaOg+6ADobSkAnQU1QM3QHdBmUgsagO6FzoYugE6HjoE7oNuh2aBA6ENJ47wcir1bPLW/dfv9MQ826axsKM83GMTXvIN2MQs19hpofDO3HY/V/uwX6AnQ89EXoBOh86EvQo9CXocegU6HD0OPQV6AnoCeh46CnoKehZ6CvQs9CF0DPQR+ARqCPQNdDV0Er0NegVeiT0Kegr0PXQR+EboAegT4ErUGfhQ5BH4aWoDugZagIfRS6EfoYNAZ9HHoeegH6BvQJaB2qQp+GPgPdDH0OugV6P1SBytD90DQ0D10D3QQtQIvQDPQ+6Ag0C41CD0MPQA9CTdAV0Bx0L3QQegjaD90HXQntgq6GslAO2g3loT3QXuhaaF9I470fCpW5k8awk8awk8awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk1awk+avk+avk+avk+avk+avk+avk+avk+avk26vk26vk26vk26vk26vk26vk26vk26vk26vk26vkza4k96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vk96vQQehh6D90H3QLigH5aE9UBa6EtoNXQ1dC+2F9oU03vvIRMMp31kfr/zwqx6dsVW7/PmpVzlCo9AUbSo4Y+o1nUvzVO1TVqdeeZJG9O6M/9fUX9fbhb6j9oGJqR/iHI3CT0U/4+TU9zjHJnr/41+c+u7naUQb96pTP9S5GoVfjn4hf10Ha/wovJHoj8w5GoV/FN3nV0UfeuWJGs/XLi7+6zlaYyl69r5V+87fXfvwr9b+/y9r38vJ0c0XfVOnRBc3NZ7K3p+d+vZbkTzR8EYfecWbjwzWu9nl6ONHdav3maBYNqApgPHej0af/Cu1r/2LqCV+vHbx5vjRR7gSXXwzWnLYbrc/Ez/6ovxE7f//IXp9ow88Wbt4Jrr4Su3i/63n+R+L/tbDtU88HAjjH9EM/VHjh1h5482I3ziU5/XQkOj4pE/t/BEQk7+RQ3k+vn2y3Jeih2PbvD1CQ/xI4wlbPbpj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3k0B76aAd1PAuyng3RTwbgp4NwW8mwLeTQHvpoB3U8C7KeDdFPBuCng3BbybAt5NAe+mgHdTwLsp4N0U8G4KeDcFvLtRwAdj2+/CPBjfnoMsvur7jtenJvfHnYwsorvN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rbjO42o7vN6G4zutuM7jaju83objO624zuNqO7zehuM7rb3NDdGxHODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM4NwZhDODMKZQTgzCGcG4cwgnBmEM9MQziGEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsRznaEsx3hbEc42xHOdoSzHeFsRzjbEc52hLMd4WxHONsbwjlcF85ctMk4VtfFpsLAzrqcNBX+Vayuf02F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nFg6nFg6nAifTiwkTiwkTiwkTiwkTiwkTiwkTiwkTiwkBZ2u3juxrjixrjixrjixrjixrjixrjixrjixrjixrjixrjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixkjixdjixdjixdjixdjixdjixdjixdjixdjixdjixdjixdjixdjixdjixdjjNtWM2xk6yqHNkUefIos6RRZ0jizpHFnWOLOocWdQ5sqhzZFHnyKLOkUWdI4s6RxZ1jizqHFnUObKoc2RR58iizpFFnSOLOkcWdY4s6hxZ1DmyqHNkUefIos6RRZ0jizpHFnWOLOocWdQ5sljRs6hzZFHnyKLOkUWdI4s6RxZ1jizqHFnUObKoc2RR58iizpFFnSOLOkcWdY4s6hxZ1DmyqHNkUefIos6RRZ0jizpHFnWOLOocWdQ5ssiesqhzZFHnyKLOkUWdI4s6RxZ1jizqHFnUObKoc2RR58iizpFFnSOLOkcWdY4s6hxZ1DmyqHNkUefIos6RRZ0jizpHFnWOLOocWdQ5sqhzZFHnyCKLzaLOkUWdI4s6RxZ1jizqHFkz361HAOxAq6gDraIONNQ60DjqQOOoA82FDjQXOtBG6kCroQNtpA402zrQVOpAG6kDbaQOtNc6UIbpQFOpA42jDrTQOtDo6EAbqQOtog40hzrQEulAS6QDzaEONEg60CDpQOOoA+2SDrSKOtB27EBzqAPNoQ60WTrQKupA06UDraIOtJE60FrsQHumAw3DDjRrOtAw7ECpzNST0CboFugOaD/0CqRD10MWaAp0J7QVuge6AboXug9qhbZBe6HXoC7odegN6GHoaWgRtA/qhV6EpkGPQfXQXGgB9Bz0BPQCNAvKQs9CU6HHoTlQBnoUmgE1Qk9BC6HnoSapqDYHQTWJoJpEUE0iqCYRVJMIqkkE1SSCahJBNYmgmkRQTSKoJhFUkwiqSQTVJIJqEkE1iaCaRFBNIqgmEVSTCKpJBNUkgmoSQTWJoJpEUE0iqCYRVJMIqkkE1SSCahJBNYmgmkRQTSKoJhFUkwiqSQTVJIJqEkE1iaCa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cZGt4yJbx0W2jotsHRfZOi6ydVxk67jI1nGRreMiW8dFto6LbB0X2TousnVcZOu4yNZxka3jIlvHRbaOi2wdF9k6LrJ1XGTruMjWcZGt4yJbx0W2jotsHRfZOi6ydVxk67jI1nGRreMiW8dFto6LbB0X2TousnVcZOu4yNZxka3jIlvHRbaOi2wdF9k6LrJ1XGTruMjWcZGt4yJbx0W2jotsHRfZOi6ydVxk67jI1nGRreMiW8dFto6LbB0X2TousnVcZOu4yNZxka3jIlvHRbaOi2wdF8tbx//kdLOj/MGvMp2+ysvxVf4zv8rU/iov/1f5JX+1/I3+Kd9oFt9oFt9oFt9oFt9oFt9oFt9oVvkb3chtbn3B77+M+hCrQjSESIZoDJEKsTrEmhBrQ6wLcXGI9SE2hEiH2BhiU4jFITaH2BJiVohLAuTS+c8/PhCVme1f3ub05W1O6798D4YfdXfTr3DO8VfK5xz/2Q95H+4f8v7bpffdTv9meK9vdN/j/jPyf8Z34v7VH/19y+/vveCzP8BnbqKMhu2jX/S7/hqnOkcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUdYVkcozUcozUcozUcozUcozUcozUdY4kcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcomUYozUcozUcozUcozUco0UYozUcozUcozUcozUcozUcozUco5kYozUcozUcozUcozUcozUcoJUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUcozUfKheyvT3TN/0lFvtxf3luRL3eMO0vNlX/OhuRNbEjexIbkTWxI3sSG5E1sSN7EhuRNbEjexIbkTWxI3sSG5E1sSN7EhuRNbEjexIbkTWxI3sSG5E1sSN7EhuRNbEjexIbkTWxI3sSG5E1sSN7EhuRN5c2Lr0+sqIvDVb+LVb+rvOofYh3Msw7mWQfzrIN5Vr48a12etS7PWpdnrcuzguVZwfKsS3nWpTyrcJ51N8/6mWf9zLN+5lkj86yRedbIPOtg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sHc8NU+PvRPEiehevSr6yLaT0aP/L/oouFPRo9ljt/9nfAOGKWG0zqETm0O/Oq6VaCOKo83oAbQWzUd3ogXoHvQgWoX2onvRQ+g+9DCahx5B+9CjqBytR0vQBrQfHUA5dBBtQo+hQ2gZ2ooeR9tQLdqJVqPDaBFaiBrQEXQUHUMZdBzNQjVoMYqhLWg72oOWoxOoDlWhJEqgGegkmo3K0Do0E51CjWgNqkRN6DQ6g86ipagaTUf1aBo6h3ahNFqBzqM8ag6VT50lAK/QW16ht7xCb3mF3vIKveUVessr9JZX6C2v0Fteobe8Qm95hd7yCr3lFXrLK/SWV+gtr9BbXqG3vEJveYXe8gq95ZWwt7ypfehRVI7WoyVoA9qPDqAcOog2ocfQIbQMbUWPo22oFu1Eq9FhtAgtRA3oCDqKjqEMOo5moRq0GMXQFrQd7UHL0QlUh6pQEiXQDHQSzUZlaB2aiU6hRrQGVaImdBqdQWfRUlSNpqN6NA2dQ7tQGq1A51EeNYfKp84RgK1jGdmHsuh2tBFdQ0X0NPoc6kJfRE+h76JetBe9gtrQc+hJ9CxqR59GB1AOdaNN6LPoEPoU+h56Bn0efRN9GX0FdaDD6DI6ir6GjqFOdANdQV9Ae9AwOoF60POohF5HX0VXURlah15AjagffRJ9Bg2gJnQataLvo0+gH6A30JfQt9EudAl9A11HG9CLaCuqRTvRd9AQeg1tRi+jV9F69BLahr6OBlENqkPfQvVoBKVD5VPnCdVOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOuspOusrO8a4yTwD2EoC9BGAvAdhLAPYSgL0EYC8B2EsA9hKAvQRgLwHYSwD2EoC9BGAvAdhLAPYSgL0E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TkG8TkG8Tht2nfJ4nfJ4nfJ4nfI4rnVoJjqNzqCzaDqahnahLFqJNqLNaD5agB5Eq9DDaB5aj5agHDqIDqFlaBtaiBrQUXQM1aAY2o72oBOoDlWhJEqgk6gMnUKNaA2qRE1oKapG9egcSqMV6DzKh8qnnn6/+9RPjf7/v2h5X3vV0fL+wGiJKY9+1bopLbdeYPLncdX63d9L+dLog29/RDas86lnfIul6ETqNG+xxCW150dfSm+/UH7EeytNXAipyuj3ur88vCQmn/KTT/X3+pR+h6dw6u7bfsRz+K3P2ff6XP1xb5P0Ht8UKbU0+tOfLn+H59Vtoz/wavmPehalKqKf/FfKw+fT2589f7onTT7VM96EjgfxX4jeEuVc6lk60R460R46hB760h76hR76hR561h66hx462B462B46ix762R76jB662x66jh66jh463x463x463x463x66lR66lR664h664h664h664h66nB66nB465h465h465h76oR76oR666R666R56pR56pR467R467R76qB767h767h767h767h767h66sR66sR568h56sx56sx769R769R769R66uB669x56uh56+R46vB46vB46+x76vR76vR76vR76vR76vR7uD3ro/nq4W+ihF+zh3qGHe4ce+sQe+sQe+sQe+sQe+sQe7kB6uAPp4Q6kh46yh45yXNNRPZqGzqFdKI1WoPMoj5pD5VO97/hiofEX/LzS8qd61dCPerHQc2O/7eQYI/rwm/86MWqpZQ4RTU8+M7ae+DxvX/WfggtqDPnUC4T5nilhmO/hDenGdTtaieJoLZqP7kQL0Cp0D9qL7kX3oXloHypHS1AOLUOr0SJ0FB1Ds9BiFEPLURVKogSagWajMjQTNaI1qBI1oTNoKapG09E0tAKdRKfQfnQkVD716bGncDQp++PoeuGzm6JX941/PtO86ML4xOiDBVPCj3PKp/omX1ZdKn8zq3dcH/u1+3lr53849tvfgQbR7egb6GU0hJ5Cw+gV9Cq6jp5FL6KX0DfRt9C30XfQCHoNHUN9KIs2omvoBvoc+gL6Ivou2oN60V70PHoOvY6+ip5EL6BPo0bUjw6gz6AcGkBN6LPoe+j76Afo8+gN9CX0ZfQVdBh9DR1FRfQ06kJtqB11o03oEPoUegZ1oMuoE11BJ1APKqGrqAyt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onpUh9Kh8qn/Qlf5F8e+ZQrKotvRSrQRxdFm9ABai+ajO9ECdA96EK1Ce9G96CF0H3oYzUOPoH3oUVSO1qMlaAPajw6gHDqINqHH0CG0DG1Fj6NtqBbtRKvRYbQILUQN6Ag6io6hDDqOZqEatBjF0Ba0He1By9EJVIeqUBIl0Ax0Es1GZWgdmolOoUa0BlWiJnQanUFn0VJUjaajejQNnUO7UBqtQOdRHjWHyqf+KwE4wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPcVg9wWz3AbfUAt9UD3FYPcFs9wG31ALfVA9xWD3BbPcBt9QC31QPjt9X/7cM+nb81lP9wD+Wj05Mr0V/qR2k6n0/9MY1DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41DB41Dx3jj8H8yj//K2M3VHWgQ3Y5eRN9AL6GX0RB6Cg2jb6JvoW+jV9Cr6DtoBL2GrqNn0THUh7JoI7qGbqDPoS+gL6Lvoj2oF+1Fz6Pn0Ovoq+hJ9AL6NGpE/egA+gzKoQHUhP7/du47OuoyUeP4hBJiEooCCoIBBBUQVECD9Fc6hAmh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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
